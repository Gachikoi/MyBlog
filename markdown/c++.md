函数仅有返回值不同不能构成重载

若一函数功能简单（函数体语句较少），则函数调用的额外开销占比较高，则应在函数前加上inline关键字，变成内联函数。具体展开与否取决于编译器。

T get_xxx() const{} 加上const关键字表明此函数为“常成员函数”，不能修改类成员变量。

UML类图用于描述一个事物的属性与行为，注意，必须有“属性”和“行为”！即变量和方法，变量在上方法在下，用横线分隔开。变量/方法前加一个“+”表示为public，“-”表示为private

子类定义的函数和父类继承的函数同名，子类同时拥有两个函数，默认使用子类的函数，可以通过Father：：使用父类命名空间来使用父类函数。

子类继承虚函数时，重写过后，虚函数被覆盖。没有重写时，子类依然可以调用父类的虚函数。

纯虚函数：不实现。
声明：virtual float getS()=0；
含有纯虚函数的类叫抽象类，仅有纯虚函数的类叫接口。
抽象类和接口不可以实例化，即`Shape s;`错误。

override需要保持参数和返回值一致，否则就是一个新函数而不是重写。

当子类定义与父类同名的非虚函数时，子类的函数会隐藏父类的函数。在这种情况下，通过子类对象调用函数时会调用子类的版本，但通过父类指针或引用调用时仍会调用基类的版本。

联编（bind）：确定具体要调用多个同名函数中的哪一个/
静态联编=编译时多态=函数重载=overload  在编译时就确定了要调用的时哪个函数（根据多个重载函数的参数列表确定）
动态联编=运行时多态=虚函数重写=override  直到运行时才直到实际调用的是哪个函数（根据指针指向对象的实际身份）

“指向子类对象/实例的父类指针/变量”

```c++
C c; // 创建 C 类对象 c
B b = c; // 对象切片，b 现在是一个 B 类型的对象
B &p = c; // p 是一个指向 C 对象 c 的 B 类型的引用
```
对象切片（slicing）
当你使用 B b = c; 进行赋值时，发生了对象切片。具体来说，以下是发生的过程：

1. 对象 c 的拷贝构造：

B b = c; 调用的是 B 类的拷贝构造函数，将对象 c 转换为基类 B 的对象。  
由于 c 是 C 类型的对象，它包含了 C 类中的所有数据成员和成员函数。  
但是，b 是 B 类型的对象，它只能包含基类 B 的部分，而 C 中新增的成员变量和成员函数都不会被复制到 b 中。  
2. 切片的结果：
b 只是一个 B 类型的对象，它包含了 B 类中的数据成员和虚函数表（vtable），但不包含 C 类中新增的部分。  
当你调用 b.foo() 时，它会调用 B 类中的 foo() 函数，因为 b 已经被切片为 B 类型。  


# 指针
## 野指针
被声明但未初始化的指针。这个指针会指向随机的内存空间，可能导致未知问题。

指针声明即被分配内存。

```c++
int *p;
*p=10;
```
第二句话是向未知的、随机的4字节内存区域，修改存储值为10，不是安全的操作。
因此我们即使在声明变量时不需要对指针进行赋地址，也需要进行如下操作：
```c++
int *p=NULL;
int *p=nullptr;
```
空指针也不是正常的指针，什么都不指向，还是需要后面分配一个地址，它只是让代码避免安全问题。
## 指针运算
指针+n或-n，即内存地址+n\*类型大小或-n\*类型大小

```c++
int v[]={0,1,2,3}
int *vp=v;
```
数组变量存储的是地址指针，因此赋给指针时不需要用&  
*vp指向数组首元素

## 动态内存分配
```c++
int *p=new int[5];
p[0]=1;
*p=1;
*(p+1)=2;
delete[] p;
```

## 指针悬挂
指针指向区域已经被回收
1. 不要轻易进行指针之间的赋值
2. delete回收空间前，确保此空间100%不再被使用

## const指针
1. 指向const（常量）的指针：const int *p / int const *p
2. const(常量)指针：int* const p=&num; 必须先初始化，因为指针的指向不能改变。
3. 指向const的const指针：const int* const p / int const * const p

# 函数
## 函数传入数组
c++中传入数组的同时一般也会传数组大小，因为在函数内很难统计数组大小。在声明处使用sizeof(arr)会正常显示数组所占地址空间；但在传入函数时，传的是一个指针，再使用sizeof(arr)显示的是指针所占的大小，在64位系统中这个值为8.

# 类与对象
## 深拷贝与浅拷贝
```c++
Person p2(p1);
```
如果利用编译器提供的拷贝构造函数，会做浅拷贝操作。
即如果p1中有一个非指针变量，会拷贝变量值；如果有一个指针，会原封不动地拷贝内存地址给p2的指针。
这样会导致析构时，p2、p1重复释放指针指向地址的内存，导致程序崩溃。

所以我们需要利用深拷贝，自定义拷贝构造函数，对指针变量新申请一块堆区空间。
```c++
//自己实现拷贝构造函数
Person(const Person &p){
    m_Age=p.m_Age;
    //m_Height=p.m_Height;编译器默认实现
    m_Height=new int(*p.m_Height);
}
```
## 初始化列表
```c++
Person(int a, int b, int c):m_A(a),m_B(b),m_C(c){}
```

## 类对象作为类成员
构造时先构造类对象再构造自身，析构则相反，先析构自身再析构自身持有的类对象。

## 静态成员
通过对象访问/通过类名访问（Person::func();）

静态成员函数和静态成员变量是绑定在类级别的，而实例成员函数和实例成员变量是绑定在对象级别的。静态成员函数不能直接访问实例成员变量和实例成员函数，因为它们不依赖于任何特定的实例。
### 静态成员变量
1. 所有对象共享同一份数据
2. 静态成员变量的声明在类内，并不初始化；定义在类外进行，内存分配也在这里发生。
3. 类内声明，类外初始化
### 静态成员函数
1. 所有对象共享同一个函数
2. 静态成员函数只能访问静态成员变量

## 常对象&常成员函数
常对象只能调用常成员函数  
常成员函数内不能修改对象的属性，除非属性前加上mutating关键字。  
常对象的属性不可被修改。但常对象可以通过调用常成员函数修改带有mutating关键字的成员变量。  